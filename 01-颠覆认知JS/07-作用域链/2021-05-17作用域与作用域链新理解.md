---
title: 作用域与作用域链新理解
date: 2021-05-17 21:43:44
categories: 
- 前端
- JavaScript
tags: 
- javaScript
- scope
- scope chain
---

关于作用域与作用域链最为典型的场景是我们在函数外部不能访问函数内部的变量，其实函数也是一个对象，比如他也有`.name`、`.length`prototype``属性，它也是一种引用类型，属于引用值，同时提到作用域与作用域链也要再次使用GO与AO

### AO对象

总结AO对象，

1. 先在函数中找变量声明提升到函数前面，这时变量的值默认给undefined
2. 获取实参，根据实参给变量赋值
3. 在函数中找函数声明，提升到函数前面，如果函数与变量名相同，函数优先
4. 执行代码

### GO对象

与函数AO类似的全局GO对象，只是少了参数部分

1. 先在函数中找变量声明提升到函数前面，这时变量的值默认给undefined
2. 在函数中找函数声明，提升到函数前面，如果函数与变量名相同，函数优先
3. 执行代码

<!--more-->

**它们总是在执行的前一刻生成**

所以分析如下代码

```javascript
function a() {
	function b() {}
  b()
 }
a()
```

1. 全局执行代码，生成GO对象，并且变量与函数定义提升

2. 此时生成函数a的作用域`scope`与`scope chain`，scope的变量我们比作一个指针，`scope chain`我们比作一个自上而下存储的数组，scope的指针指向作用域链的第0位，也就是GO，（这是在函数定义时的行为）

{% asset_img 1.jpg %}

3. 当函数a执行前一刻，生成函数的AO，其中包含着函数a内的变量定义，`scope chain`中在第0位插入AO的指针，GO变为第二位

{% asset_img 2.jpg %}

4. 函数a执行的时候函数b已经定义，存在函数a的AO中，创建函数b的作用域与作用域链，此时还未执行，b继承a的作用域与作用域链，与函数a相同
5. 函数b执行，生成了b的AO，插入`scope chain`第一位

{% asset_img 3.jpg %}

6. b函数执行完，销毁b的AO与作用域链，同时当a执行完时，b的作用域销毁，a回到被定义的状态，go执行完，销毁a的作用域

{% asset_img 4.jpg %}

这也描述了为什么在函数外不能访问函数内部的变量，只有函数内部的变量在函数执行时才存在于函数的AO，执行完就会销毁，所以无论你访问的语句在函数的上面还是下面都访问不到